/**
 * @fileoverview Firestore Security Rules for the application.
 *
 * Core Philosophy:
 * This ruleset prioritizes a secure, owner-centric model for user-specific data while allowing public read access to product and category information.
 *
 * Data Structure:
 * - Products and Categories are stored in top-level collections with public read access and owner-only writes (the store that owns it).
 * - User-specific data (clients, invoices, stores, units, settings) is nested under /users/{userId}.
 *
 * Key Security Decisions:
 * - Public listing of user collections is disallowed to prevent unauthorized data discovery.
 * - Write access to Products and Categories are limited to only the owner to maintain data integrity.
 *
 * Denormalization for Authorization:
 * - The `Store` entity has a `ownerId` field to easily determine the store owner.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows public read access to products, but restricts writes to the owner store.
     * @path /products/{productId}
     * @allow get, list: if true;
     * @allow create: if request.auth != null && request.resource.data.storeId in (get(/databases/$(database)/documents/users/$(request.auth.uid)/stores).data.id);
     * @allow update: if request.auth != null && resource.data.storeId in (get(/databases/$(database)/documents/users/$(request.auth.uid)/stores).data.id) && resource != null;
     * @allow delete: if request.auth != null && resource.data.storeId in (get(/databases/$(database)/documents/users/$(request.auth.uid)/stores).data.id) && resource != null;
     * @principle Allows public read access while enforcing owner-only writes based on the `storeId` field.
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.storeId == getStoreIdByProductId(productId).storeId;
      allow update: if isSignedIn() && isExistingProductOwner(productId);
      allow delete: if isSignedIn() && isExistingProductOwner(productId);

      function getStoreIdByProductId(productId) {
        return get(/databases/$(database)/documents/products/$(productId)).data.storeId;
      }
    }

    /**
     * @description Allows public read access to categories, but restricts writes to the owner store.
     * @path /categories/{categoryId}
     * @allow get, list: if true;
     * @allow create: if request.auth != null && request.resource.data.storeId in (get(/databases/$(database)/documents/users/$(request.auth.uid)/stores).data.id);
     * @allow update: if request.auth != null && resource.data.storeId in (get(/databases/$(database)/documents/users/$(request.auth.uid)/stores).data.id) && resource != null;
     * @allow delete: if request.auth != null && resource.data.storeId in (get(/databases/$(database)/documents/users/$(request.auth.uid)/stores).data.id) && resource != null;
     * @principle Allows public read access while enforcing owner-only writes based on the `storeId` field.
     */
    match /categories/{categoryId} {
        allow get, list: if true;
        allow create: if isSignedIn() && request.resource.data.storeId == getStoreIdByCategoryId(categoryId).storeId;
        allow update: if isSignedIn() && isExistingCategoryOwner(categoryId);
        allow delete: if isSignedIn() && isExistingCategoryOwner(categoryId);

        function getStoreIdByCategoryId(categoryId) {
          return get(/databases/$(database)/documents/categories/$(categoryId)).data.storeId;
        }
    }

    /**
     * @description Manages user-specific client data with owner-only access.
     * @path /users/{userId}/clients/{clientId}
     * @allow get: if isOwner(userId);
     * @allow list: if isOwner(userId);
     * @allow create: if isOwner(userId);
     * @allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
     * @allow delete: if isExistingOwner(userId);
     * @principle Enforces document ownership for all operations within a user's client collection.
     */
    match /users/{userId}/clients/{clientId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == clientId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages user-specific invoice data with owner-only access.
     * @path /users/{userId}/invoices/{invoiceId}
     * @allow get: if isOwner(userId);
     * @allow list: if isOwner(userId);
     * @allow create: if isOwner(userId);
     * @allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
     * @allow delete: if isExistingOwner(userId);
     * @principle Enforces document ownership for all operations within a user's invoice collection.
     */
    match /users/{userId}/invoices/{invoiceId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == invoiceId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages user-specific store data with owner-only access.
     * @path /users/{userId}/stores/{storeId}
     * @allow get: if isOwner(userId);
     * @allow list: if isOwner(userId);
     * @allow create: if isOwner(userId) && request.resource.data.ownerId == userId && request.resource.data.id == storeId;
     * @allow update: if isExistingOwner(userId) && request.resource.data.ownerId == resource.data.ownerId && request.resource.data.id == resource.data.id;
     * @allow delete: if isExistingOwner(userId);
     * @principle Enforces document ownership for all operations within a user's store collection, and validates that the ownerId matches the userId in the path.
     */
    match /users/{userId}/stores/{storeId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.ownerId == userId && request.resource.data.id == storeId;
      allow update: if isExistingOwner(userId) && request.resource.data.ownerId == resource.data.ownerId && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages user-specific unit data with owner-only access.
     * @path /users/{userId}/units/{unitId}
     * @allow get: if isOwner(userId);
     * @allow list: if isOwner(userId);
     * @allow create: if isOwner(userId) && request.resource.data.id == unitId;
     * @allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
     * @allow delete: if isExistingOwner(userId);
     * @principle Enforces document ownership for all operations within a user's unit collection.
     */
    match /users/{userId}/units/{unitId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == unitId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages user-specific settings (like toolbar positions) with owner-only access.
     * @path /users/{userId}/settings/toolbarPositions
     * @allow get: if isOwner(userId);
     * @allow list: if isOwner(userId);
     * @allow create: if isOwner(userId);
     * @allow update: if isExistingOwner(userId);
     * @allow delete: if isExistingOwner(userId);
     * @principle Enforces document ownership for all operations on the user's settings document.
     */
    match /users/{userId}/settings/toolbarPositions {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    // ---- Helper functions ----

    /**
     * @description Checks if the request is authenticated.
     * @return {boolean} True if the request is authenticated, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user is the owner of the resource.
     * @param {string} userId The user ID to compare against the request's authentication UID.
     * @return {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner of the resource and the resource exists.
     *              Use this function for update and delete operations to prevent acting on non-existent documents.
     * @param {string} userId The user ID to compare against the request's authentication UID.
     * @return {boolean} True if the user is the owner and the resource exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    function isExistingProductOwner(productId) {
      return request.resource.data.storeId == get(/databases/$(database)/documents/products/$(productId)).data.storeId && resource != null;
    }

    function isExistingCategoryOwner(categoryId) {
      return request.resource.data.storeId == get(/databases/$(database)/documents/categories/$(categoryId)).data.storeId && resource != null;
    }
  }
}