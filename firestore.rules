/**
 * @fileoverview Firestore Security Rules for the application.
 *
 * Core Philosophy:
 * This ruleset enforces a hybrid security model: public read access for some collections
 * (e.g., Products, Categories, Stores), and strict user-ownership for other collections
 * (e.g., Clients, Invoices, Units, Settings).
 *
 * Data Structure:
 * - /products/{productId}: Public product catalog.
 * - /categories/{categoryId}: Public category list.
 * - /stores/{storeId}: Public store list.
 * - /users/{userId}/clients/{clientId}: Private client data, owned by the user.
 * - /users/{userId}/invoices/{invoiceId}: Private invoice data, owned by the user.
 * - /users/{userId}/units/{unitId}: Private unit data, owned by the user.
 * - /users/{userId}/settings/toolbarPositions: Private settings data, owned by the user.
 *
 * Key Security Decisions:
 * - Public read access is granted to /products, /categories, and /stores to allow for
 *   unauthenticated browsing.  Writes to these collections are restricted to ensure
 *   only authorized users can modify the data. For the prototyping phase, write access is disabled
 *   on public read collections, and marked for future review.
 * - All data under /users/{userId} is strictly controlled by the owning user.
 * - Listing of documents is allowed for user-owned subcollections.
 *
 * Denormalization for Authorization:
 *  - The current data model includes an `ownerId` field on the `Store` entity, which is
 *    used for authorization. Ensure that this field is reliably populated and immutable
 *    for proper security.
 *
 * Structural Segregation:
 *  - Public data (products, categories, stores) is stored in top-level collections, while
 *    private user data (clients, invoices, units) is stored under the /users/{userId} path,
 *    ensuring clear separation of concerns and simplifying security rules.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows anyone to read products; writes are restricted to ensure data integrity (disabled for prototyping).
     * @path /products/{productId}
     * @allow get, list: if true;
     * @deny create, update, delete: if false;
     * @principle Public read, restricted write (owner-only writes to be implemented later).
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once authorization is implemented.
    }

    /**
     * @description Allows anyone to read categories; writes are restricted to ensure data integrity (disabled for prototyping).
     * @path /categories/{categoryId}
     * @allow get, list: if true;
     * @deny create, update, delete: if false;
     * @principle Public read, restricted write (owner-only writes to be implemented later).
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once authorization is implemented.
    }

    /**
     * @description Allows anyone to read stores; writes are restricted to the store owner.
     * @path /stores/{storeId}
     * @allow get, list: if true;
     * @allow create: if request.auth != null && request.resource.data.ownerId == request.auth.uid;
     * @allow update: if request.auth != null && resource.data.ownerId == request.auth.uid;
     * @allow delete: if request.auth != null && resource.data.ownerId == request.auth.uid;
     * @principle Public read, owner-only write.
     */
    match /stores/{storeId} {
      allow get, list: if true;
      allow create: if request.auth != null && request.resource.data.ownerId == request.auth.uid;
      allow update: if request.auth != null && request.resource.data.ownerId == request.auth.uid;
      allow delete: if request.auth != null && resource.data.ownerId == request.auth.uid;
    }

    /**
     * @description Enforces user-specific data access for clients.
     * @path /users/{userId}/clients/{clientId}
     * @allow get, list: if isOwner(userId);
     * @allow create: if isOwner(userId);
     * @allow update: if isOwner(userId);
     * @allow delete: if isOwner(userId);
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/clients/{clientId} {
      allow get, list: if request.auth.uid == userId;
      allow create: if request.auth.uid == userId;
      allow update: if request.auth.uid == userId;
      allow delete: if request.auth.uid == userId;
    }

    /**
     * @description Enforces user-specific data access for invoices.
     * @path /users/{userId}/invoices/{invoiceId}
     * @allow get, list: if isOwner(userId);
     * @allow create: if isOwner(userId);
     * @allow update: if isOwner(userId);
     * @allow delete: if isOwner(userId);
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/invoices/{invoiceId} {
      allow get, list: if request.auth.uid == userId;
      allow create: if request.auth.uid == userId;
      allow update: if request.auth.uid == userId;
      allow delete: if request.auth.uid == userId;
    }

    /**
     * @description Enforces user-specific data access for units.
     * @path /users/{userId}/units/{unitId}
     * @allow get, list: if isOwner(userId);
     * @allow create: if isOwner(userId);
     * @allow update: if isOwner(userId);
     * @allow delete: if isOwner(userId);
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/units/{unitId} {
      allow get, list: if request.auth.uid == userId;
      allow create: if request.auth.uid == userId;
      allow update: if request.auth.uid == userId;
      allow delete: if request.auth.uid == userId;
    }

    /**
     * @description Enforces user-specific data access for toolbar settings.
     * @path /users/{userId}/settings/toolbarPositions
     * @allow get: if isOwner(userId);
     * @allow create: if isOwner(userId);
     * @allow update: if isOwner(userId);
     * @allow delete: if isOwner(userId);
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/settings/toolbarPositions {
      allow get: if request.auth.uid == userId;
      allow create: if request.auth.uid == userId;
      allow update: if request.auth.uid == userId;
      allow delete: if request.auth.uid == userId;
    }

    /**
     * @description Catches ALL paths, and allows the logged in user access
     * @path ALL Paths
     * @allow get: if isSignedIn();
     * @allow list: if isSignedIn();
     * @allow create: if isSignedIn();
     * @allow update: if isSignedIn() && resource != null;
     * @allow delete: if isSignedIn() && resource != null;
     * @principle Default deny any write not explicitly allowed in more specific rule.
     */
    match /{path=**} {
       allow get: if false;
       allow list: if false;
       allow create: if false;
       allow update: if false;
       allow delete: if false;
    }
  }
}