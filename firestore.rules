/**
 * @fileoverview Firestore Security Rules for the application.
 *
 * Core Philosophy:
 * This ruleset enforces a hybrid security model. It implements user-ownership for private data stored
 * under `/users/{userId}`, while allowing public read access to product and category catalogs.
 *
 * Data Structure:
 * - `/products/{productId}`: Public collection of products.
 * - `/categories/{categoryId}`: Public collection of categories.
 * - `/users/{userId}/clients/{clientId}`: Private clients for each user.
 * - `/users/{userId}/invoices/{invoiceId}`: Private invoices for each user.
 * - `/users/{userId}/stores/{storeId}`: Private stores for each user.
 * - `/users/{userId}/units/{unitId}`: Private units for each user.
 * - `/users/{userId}/settings/toolbarPositions`: Private settings for each user.
 *
 * Key Security Decisions:
 * - Public read access to `/products` and `/categories` is granted, but write access is restricted.  Since there is no ownerId on these records, writes are not allowed.
 * - User listing is implicitly disallowed by the data model.
 * - Strict user-ownership is enforced for all data nested under `/users/{userId}`.
 *
 * Denormalization for Authorization:
 * N/A in this version.  Future iterations may benefit from denormalizing ownership data.
 *
 * Structural Segregation:
 * Private user data is stored in user-specific subcollections to prevent accidental exposure.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows public read access to products, but restricts writes.
     * @path /products/{productId}
     * @allow get, list: if true;
     * @deny create, update, delete: if false;
     * @principle Public read, no write access to products.
     */
    match /products/{productId} {
      allow get: if true;
      allow list: if true;
      allow create, update, delete: if false; // There is no `ownerId` field in the entity definition.
    }

    /**
     * @description Allows public read access to categories, but restricts writes.
     * @path /categories/{categoryId}
     * @allow get, list: if true;
     * @deny create, update, delete: if false;
     * @principle Public read, no write access to categories.
     */
    match /categories/{categoryId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // There is no ownerId field in the entity definition.
      allow update: if false; // There is no ownerId field in the entity definition.
      allow delete: if false; // There is no ownerId field in the entity definition.
    }

    /**
     * @description Enforces user-ownership for client documents.
     * @path /users/{userId}/clients/{clientId}
     * @allow create: if isSignedIn() && request.auth.uid == userId;
     * @allow get, list: if isOwner(userId);
     * @allow update: if isExistingOwner(userId);
     * @allow delete: if isExistingOwner(userId);
     * @deny create: if !isSignedIn() || request.auth.uid != userId;
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId}/clients/{clientId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces user-ownership for invoice documents.
     * @path /users/{userId}/invoices/{invoiceId}
     * @allow create: if isSignedIn() && request.auth.uid == userId;
     * @allow get, list: if isOwner(userId);
     * @allow update: if isExistingOwner(userId);
     * @allow delete: if isExistingOwner(userId);
     * @deny create: if !isSignedIn() || request.auth.uid != userId;
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId}/invoices/{invoiceId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces user-ownership for store documents.
     * @path /users/{userId}/stores/{storeId}
     * @allow create: if isSignedIn() && request.auth.uid == userId;
     * @allow get, list: if isOwner(userId);
     * @allow update: if isExistingOwner(userId);
     * @allow delete: if isExistingOwner(userId);
     * @deny create: if !isSignedIn() || request.auth.uid != userId;
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId}/stores/{storeId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces user-ownership for unit documents.
     * @path /users/{userId}/units/{unitId}
     * @allow create: if isSignedIn() && request.auth.uid == userId;
     * @allow get, list: if isOwner(userId);
     * @allow update: if isExistingOwner(userId);
     * @allow delete: if isExistingOwner(userId);
     * @deny create: if !isSignedIn() || request.auth.uid != userId;
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId}/units/{unitId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces user-ownership for toolbar settings.
     * @path /users/{userId}/settings/toolbarPositions
     * @allow create: if isSignedIn() && request.auth.uid == userId;
     * @allow get, list: if isOwner(userId);
     * @allow update: if isExistingOwner(userId);
     * @allow delete: if isExistingOwner(userId);
     * @deny create: if !isSignedIn() || request.auth.uid != userId;
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId}/settings/toolbarPositions {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }
  }

  // Helper functions
  function isSignedIn() {
    return request.auth != null;
  }

  function isOwner(userId) {
    return isSignedIn() && request.auth.uid == userId;
  }

  function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
  }
}